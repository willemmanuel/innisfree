<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>ListMonth.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
</script>

<script src="../../../js/jquery.js"></script>
<script src="../../../js/darkfish.js"></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../../assets/javascripts/FullCalendar/ListMonth_js.html">ListMonth.js</a>
  
    <li><a href="../../../assets/javascripts/application_js.html">application.js</a>
  
    <li><a href="../../../assets/javascripts/appointments_js_coffee.html">appointments.js.coffee</a>
  
    <li><a href="../../../assets/javascripts/cars_js_coffee.html">cars.js.coffee</a>
  
    <li><a href="../../../assets/javascripts/houses_js_coffee.html">houses.js.coffee</a>
  
    <li><a href="../../../assets/javascripts/physicians_js_coffee.html">physicians.js.coffee</a>
  
    <li><a href="../../../assets/javascripts/reports_js_coffee.html">reports.js.coffee</a>
  
    <li><a href="../../../assets/javascripts/residents_js_coffee.html">residents.js.coffee</a>
  
    <li><a href="../../../assets/javascripts/settings_js_coffee.html">settings.js.coffee</a>
  
    <li><a href="../../../assets/javascripts/test_js_coffee.html">test.js.coffee</a>
  
    <li><a href="../../../assets/javascripts/users_js_coffee.html">users.js.coffee</a>
  
    <li><a href="../../../assets/stylesheets/application_css_sass.html">application.css.sass</a>
  
    <li><a href="../../../assets/stylesheets/bootswatch_css.html">bootswatch.css</a>
  
    <li><a href="../../../assets/stylesheets/list_css.html">list.css</a>
  
    <li><a href="../../../assets/stylesheets/mobile_css.html">mobile.css</a>
  
    <li><a href="../../../assets/stylesheets/reports_css_scss.html">reports.css.scss</a>
  
    <li><a href="../../../assets/stylesheets/settings_css_scss.html">settings.css.scss</a>
  
    <li><a href="../../../assets/stylesheets/users_css_scss.html">users.css.scss</a>
  
    <li><a href="../../../views/appointments/index_json_jbuilder.html">index.json.jbuilder</a>
  
    <li><a href="../../../views/appointments/show_json_jbuilder.html">show.json.jbuilder</a>
  
    <li><a href="../../../views/cars/get_reservations_json_jbuilder.html">get_reservations.json.jbuilder</a>
  
    <li><a href="../../../views/cars/index_json_jbuilder.html">index.json.jbuilder</a>
  
    <li><a href="../../../views/cars/show_json_jbuilder.html">show.json.jbuilder</a>
  
    <li><a href="../../../views/doctors/index_json_jbuilder.html">index.json.jbuilder</a>
  
    <li><a href="../../../views/doctors/show_json_jbuilder.html">show.json.jbuilder</a>
  
    <li><a href="../../../views/houses/index_json_jbuilder.html">index.json.jbuilder</a>
  
    <li><a href="../../../views/houses/show_json_jbuilder.html">show.json.jbuilder</a>
  
    <li><a href="../../../views/reports/index_json_jbuilder.html">index.json.jbuilder</a>
  
    <li><a href="../../../views/residents/show_json_jbuilder.html">show.json.jbuilder</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page assets/javascripts/FullCalendar/ListMonth.js">

<pre>An abstract class for the &quot;list&quot; views. Renders one or more rows of day cells.</pre>
<hr>

<p>// It is a manager for a DayGrid subcomponent, which does most of the heavy
lifting. // It is responsible for managing width/height. var FC =
$.fullCalendar;</p>

<pre>FullCalendar-specific DOM Utilities
Copied from fullcalendar.js -- so much for DRY</pre>
<hr>

<p>// Given the scrollbar widths of some other container, create
borders/margins on rowEls in order to match the left // and right space
that was offset by the scrollbars. A 1-pixel border first, then margin
beyond that. function compensateScroll(rowEls, scrollbarWidths) {</p>

<pre>if (scrollbarWidths.left) {
        rowEls.css({
                &#39;border-left-width&#39;: 1,
                &#39;margin-left&#39;: scrollbarWidths.left - 1
        });
}
if (scrollbarWidths.right) {
        rowEls.css({
                &#39;border-right-width&#39;: 1,
                &#39;margin-right&#39;: scrollbarWidths.right - 1
        });
}</pre>

<p>}</p>

<p>// Undoes compensateScroll and restores all borders/margins function
uncompensateScroll(rowEls) {</p>

<pre>rowEls.css({
        &#39;margin-left&#39;: &#39;&#39;,
        &#39;margin-right&#39;: &#39;&#39;,
        &#39;border-left-width&#39;: &#39;&#39;,
        &#39;border-right-width&#39;: &#39;&#39;
});</pre>

<p>}</p>

<p>// Make the mouse cursor express that an event is not allowed in the
current area function disableCursor() {</p>

<pre>$(&#39;body&#39;).addClass(&#39;fc-not-allowed&#39;);</pre>

<p>}</p>

<p>// Returns the mouse cursor to its original look function enableCursor() {</p>

<pre>$(&#39;body&#39;).removeClass(&#39;fc-not-allowed&#39;);</pre>

<p>}</p>

<p>// Given a total available height to fill, have `els` (essentially child
rows) expand to accomodate. // By default, all elements that are shorter
than the recommended height are expanded uniformly, not considering // any
other els that are already too tall. if `shouldRedistribute` is on, it
considers these tall rows and  // reduces the available height. function
distributeHeight(els, availableHeight, shouldRedistribute) {</p>

<pre>// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.

var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
var flexEls = []; // elements that are allowed to expand. array of DOM nodes
var flexOffsets = []; // amount of vertical space it takes up
var flexHeights = []; // actual css height
var usedHeight = 0;

undistributeHeight(els); // give all elements their natural height

// find elements that are below the recommended height (expandable).
// important to query for heights in a single first pass (to avoid reflow oscillation).
els.each(function(i, el) {
        var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = $(el).outerHeight(true);

        if (naturalOffset &lt; minOffset) {
                flexEls.push(el);
                flexOffsets.push(naturalOffset);
                flexHeights.push($(el).height());
        }
        else {
                // this element stretches past recommended height (non-expandable). mark the space as occupied.
                usedHeight += naturalOffset;
        }
});

// readjust the recommended height to only consider the height available to non-maxed-out rows.
if (shouldRedistribute) {
        availableHeight -= usedHeight;
        minOffset1 = Math.floor(availableHeight / flexEls.length);
        minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
}

// assign heights to all expandable elements
$(flexEls).each(function(i, el) {
        var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = flexOffsets[i];
        var naturalHeight = flexHeights[i];
        var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

        if (naturalOffset &lt; minOffset) { // we check this again because redistribution might have changed things
                $(el).height(newHeight);
        }
});</pre>

<p>}</p>

<p>// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {</p>

<pre class="ruby"><span class="ruby-identifier">els</span>.<span class="ruby-identifier">height</span>(<span class="ruby-string">&#39;&#39;</span>);
</pre>

<p>}</p>

<p>// Given `els`, a jQuery set of &lt;td&gt; cells, find the cell with the
largest natural width and set the widths of all the // cells to be that
width. // PREREQUISITE: if you want a cell to take up width, it needs to
have a single inner element w/ display:inline function matchCellWidths(els)
{</p>

<pre>var maxInnerWidth = 0;

els.find(&#39;&gt; *&#39;).each(function(i, innerEl) {
        var innerWidth = $(innerEl).outerWidth();
        if (innerWidth &gt; maxInnerWidth) {
                maxInnerWidth = innerWidth;
        }
});

maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

els.width(maxInnerWidth);

return maxInnerWidth;</pre>

<p>}</p>

<p>// Turns a container element into a scroller if its contents is taller than
the allotted height. // Returns true if the element is now a scroller,
false otherwise. // NOTE: this method is best because it takes weird
zooming dimensions into account function setPotentialScroller(containerEl,
height) {</p>

<pre>containerEl.height(height).addClass(&#39;fc-scroller&#39;);

// are scrollbars needed?
if (containerEl[0].scrollHeight - 1 &gt; containerEl[0].clientHeight) { // !!! -1 because IE is often off-by-one :(
        return true;
}

unsetScroller(containerEl); // undo
return false;</pre>

<p>}</p>

<p>// Takes an element that might have been a scroller, and turns it back into
a normal element. function unsetScroller(containerEl) {</p>

<pre class="ruby"><span class="ruby-identifier">containerEl</span>.<span class="ruby-identifier">height</span>(<span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">removeClass</span>(<span class="ruby-string">&#39;fc-scroller&#39;</span>);
</pre>

<p>}</p>

<p>/* General DOM Utilities ———————————————————————————————————————-*/</p>

<p>// borrowed from <a
href="https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51">github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51</a>
function getScrollParent(el) {</p>

<pre>var position = el.css(&#39;position&#39;),
        scrollParent = el.parents().filter(function() {
                var parent = $(this);
                return (/(auto|scroll)/).test(
                        parent.css(&#39;overflow&#39;) + parent.css(&#39;overflow-y&#39;) + parent.css(&#39;overflow-x&#39;)
                );
        }).eq(0);

return position === &#39;fixed&#39; || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;</pre>

<p>}</p>

<p>// Given a container element, return an object with the pixel values of the
left/right scrollbars. // Left scrollbars might occur on RTL browsers (IE
maybe?) but I have not tested. // PREREQUISITE: container element must have
a single child with display:block function getScrollbarWidths(container) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">containerLeft</span> = <span class="ruby-identifier">container</span>.<span class="ruby-identifier">offset</span>().<span class="ruby-identifier">left</span>;
<span class="ruby-identifier">var</span> <span class="ruby-identifier">containerRight</span> = <span class="ruby-identifier">containerLeft</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">container</span>.<span class="ruby-identifier">width</span>();
<span class="ruby-identifier">var</span> <span class="ruby-identifier">inner</span> = <span class="ruby-identifier">container</span>.<span class="ruby-identifier">children</span>();
<span class="ruby-identifier">var</span> <span class="ruby-identifier">innerLeft</span> = <span class="ruby-identifier">inner</span>.<span class="ruby-identifier">offset</span>().<span class="ruby-identifier">left</span>;
<span class="ruby-identifier">var</span> <span class="ruby-identifier">innerRight</span> = <span class="ruby-identifier">innerLeft</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">inner</span>.<span class="ruby-identifier">outerWidth</span>();

<span class="ruby-keyword">return</span> {
        <span class="ruby-identifier">left</span><span class="ruby-operator">:</span> <span class="ruby-identifier">innerLeft</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">containerLeft</span>,
        <span class="ruby-identifier">right</span><span class="ruby-operator">:</span> <span class="ruby-identifier">containerRight</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">innerRight</span>
};
</pre>

<p>}</p>

<p>// Returns a boolean whether this was a left mouse click and no ctrl key
(which means right click on Mac) function isPrimaryMouseButton(ev) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">ev</span>.<span class="ruby-identifier">which</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">ev</span>.<span class="ruby-identifier">ctrlKey</span>;
</pre>

<p>}</p>

<p>/* FullCalendar-specific Misc Utilities
———————————————————————————————————————-*/</p>

<p>// Creates a basic segment with the intersection of the two ranges. Returns
undefined if no intersection. // Expects all dates to be normalized to the
same timezone beforehand. // TODO: move to date section? function
intersectionToSeg(subjectRange, constraintRange) {</p>

<pre>var subjectStart = subjectRange.start;
var subjectEnd = subjectRange.end;
var constraintStart = constraintRange.start;
var constraintEnd = constraintRange.end;
var segStart, segEnd;
var isStart, isEnd;

if (subjectEnd &gt; constraintStart &amp;&amp; subjectStart &lt; constraintEnd) { // in bounds at all?

        if (subjectStart &gt;= constraintStart) {
                segStart = subjectStart.clone();
                isStart = true;
        }
        else {
                segStart = constraintStart.clone();
                isStart =  false;
        }

        if (subjectEnd &lt;= constraintEnd) {
                segEnd = subjectEnd.clone();
                isEnd = true;
        }
        else {
                segEnd = constraintEnd.clone();
                isEnd = false;
        }

        return {
                start: segStart,
                end: segEnd,
                isStart: isStart,
                isEnd: isEnd
        };
}</pre>

<p>}</p>

<p>function smartProperty(obj, name) { // get a camel-cased/namespaced
property of an object</p>

<pre>obj = obj || {};
if (obj[name] !== undefined) {
        return obj[name];
}
var parts = name.split(/(?=[A-Z])/),
        i = parts.length - 1, res;
for (; i&gt;=0; i--) {
        res = obj[parts[i].toLowerCase()];
        if (res !== undefined) {
                return res;
        }
}
return obj[&#39;default&#39;];</pre>

<p>}</p>

<p>/* A component that renders a grid of whole-days that runs horizontally.
There can be multiple rows, one per week.
———————————————————————————————————————-*/</p>

<p>var DayGrid = FC.Grid.extend({</p>

<pre>numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal
bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid
breakOnWeeks: null, // should create a new row for each week? set by outside view

cellDates: null, // flat chronological array of each cell&#39;s dates
dayToCellOffsets: null, // maps days offsets from grid&#39;s start date, to cell offsets

rowEls: null, // set of fake row elements
dayEls: null, // set of whole-day elements comprising the row&#39;s background
helperEls: null, // set of cell skeleton elements for rendering the mock event &quot;helper&quot;

// Renders the rows and columns into the component&#39;s `this.el`, which should already be assigned.
// isRigid determins whether the individual rows should ignore the contents and be a constant height.
// Relies on the view&#39;s colCnt and rowCnt. In the future, this component should probably be self-sufficient.
render: function(isRigid) {
        var view = this.view;
        var rowCnt = this.rowCnt;
        var colCnt = this.colCnt;
        var cellCnt = rowCnt * colCnt;
        var html = &#39;&#39;;
        var row;
        var i, cell;

        for (row = 0; row &lt; rowCnt; row++) {
                html += this.dayRowHtml(row, isRigid);
        }
        this.el.html(html);

        this.rowEls = this.el.find(&#39;.fc-row&#39;);
        this.dayEls = this.el.find(&#39;.fc-day&#39;);

        // trigger dayRender with each cell&#39;s element
        for (i = 0; i &lt; cellCnt; i++) {
                cell = this.getCell(i);
                view.trigger(&#39;dayRender&#39;, null, cell.start, this.dayEls.eq(i));
        }

        FC.Grid.prototype.render.call(this); // call the super-method
},

destroy: function() {
        this.destroySegPopover();
        FC.Grid.prototype.destroy.call(this); // call the super-method
},

// Generates the HTML for a single row. `row` is the row number.
dayRowHtml: function(row, isRigid) {
        var view = this.view;
        var classes = [ &#39;fc-row&#39;, &#39;fc-week&#39;, view.widgetContentClass ];

        if (isRigid) {
                classes.push(&#39;fc-rigid&#39;);
        }

        return &#39;&#39; +
                &#39;&lt;div class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&gt;&#39; +
                        &#39;&lt;div class=&quot;fc-bg&quot;&gt;&#39; +
                                &#39;&lt;table&gt;&#39; +
                                        this.rowHtml(&#39;day&#39;, row) + // leverages RowRenderer. calls dayCellHtml()
                                &#39;&lt;/table&gt;&#39; +
                        &#39;&lt;/div&gt;&#39; +
                        &#39;&lt;div class=&quot;fc-content-skeleton&quot;&gt;&#39; +
                                &#39;&lt;table&gt;&#39; +
                                        (this.numbersVisible ?
                                                &#39;&lt;thead&gt;&#39; +
                                                        this.rowHtml(&#39;number&#39;, row) + // leverages RowRenderer. View will define render method
                                                &#39;&lt;/thead&gt;&#39; :
                                                &#39;&#39;
                                                ) +
                                &#39;&lt;/table&gt;&#39; +
                        &#39;&lt;/div&gt;&#39; +
                &#39;&lt;/div&gt;&#39;;
},

// Renders the HTML for a whole-day cell. Will eventually end up in the day-row&#39;s background.
// We go through a &#39;day&#39; row type instead of just doing a &#39;bg&#39; row type so that the View can do custom rendering
// specifically for whole-day rows, whereas a &#39;bg&#39; might also be used for other purposes (TimeGrid bg for example).
dayCellHtml: function(cell) {
        return this.bgCellHtml(cell);
},

/* Options
------------------------------------------------------------------------------------------------------------------*/

// Computes a default column header formatting string if `colFormat` is not explicitly defined
computeColHeadFormat: function() {
        if (this.rowCnt &gt; 1) { // more than one week row. day numbers will be in each cell
                return &#39;ddd&#39;; // &quot;Sat&quot;
        }
        else if (this.colCnt &gt; 1) { // multiple days, so full single date string WON&#39;T be in title text
                return this.view.opt(&#39;dayOfMonthFormat&#39;); // &quot;Sat 12/10&quot;
        }
        else { // single day, so full single date string will probably be in title text
                return &#39;dddd&#39;; // &quot;Saturday&quot;
        }
},

// Computes a default event time formatting string if `timeFormat` is not explicitly defined
computeEventTimeFormat: function() {
        return this.view.opt(&#39;extraSmallTimeFormat&#39;); // like &quot;6p&quot; or &quot;6:30p&quot;
},

// Computes a default `displayEventEnd` value if one is not expliclty defined
computeDisplayEventEnd: function() {
        return this.colCnt == 1; // we&#39;ll likely have space if there&#39;s only one day
},

/* Cell System
------------------------------------------------------------------------------------------------------------------*/

// Initializes row/col information
updateCells: function() {
        var cellDates;
        var firstDay;
        var rowCnt;
        var colCnt;

        this.updateCellDates(); // populates cellDates and dayToCellOffsets
        cellDates = this.cellDates;

        if (this.breakOnWeeks) {
                // count columns until the day-of-week repeats
                firstDay = cellDates[0].day();
                for (colCnt = 1; colCnt &lt; cellDates.length; colCnt++) {
                        if (cellDates[colCnt].day() == firstDay) {
                                break;
                        }
                }
                rowCnt = Math.ceil(cellDates.length / colCnt);
        }
        else {
                rowCnt = 1;
                colCnt = cellDates.length;
        }

        this.rowCnt = rowCnt;
        this.colCnt = colCnt;
},

// Populates cellDates and dayToCellOffsets
updateCellDates: function() {
        var view = this.view;
        var date = this.start.clone();
        var dates = [];
        var offset = -1;
        var offsets = [];

        while (date.isBefore(this.end)) { // loop each day from start to end
                if (view.isHiddenDay(date)) {
                        offsets.push(offset + 0.5); // mark that it&#39;s between offsets
                }
                else {
                        offset++;
                        offsets.push(offset);
                        dates.push(date.clone());
                }
                date.add(1, &#39;days&#39;);
        }

        this.cellDates = dates;
        this.dayToCellOffsets = offsets;
},

// Given a cell object, generates a range object
computeCellRange: function(cell) {
        var colCnt = this.colCnt;
        var index = cell.row * colCnt + (this.isRTL ? colCnt - cell.col - 1 : cell.col);
        var start = this.cellDates[index].clone();
        var end = start.clone().add(1, &#39;day&#39;);

        return { start: start, end: end };
},

// Retrieves the element representing the given row
getRowEl: function(row) {
        return this.rowEls.eq(row);
},

// Retrieves the element representing the given column
getColEl: function(col) {
        return this.dayEls.eq(col);
},

// Gets the whole-day element associated with the cell
getCellDayEl: function(cell) {
        return this.dayEls.eq(cell.row * this.colCnt + cell.col);
},

// Overrides Grid&#39;s method for when row coordinates are computed
computeRowCoords: function() {
        var rowCoords = FC.Grid.prototype.computeRowCoords.call(this); // call the super-method

        // hack for extending last row (used by AgendaView)
        rowCoords[rowCoords.length - 1].bottom += this.bottomCoordPadding;

        return rowCoords;
},

/* Dates
------------------------------------------------------------------------------------------------------------------*/

// Slices up a date range by row into an array of segments
rangeToSegs: function(range) {
        var isRTL = this.isRTL;
        var rowCnt = this.rowCnt;
        var colCnt = this.colCnt;
        var segs = [];
        var first, last; // inclusive cell-offset range for given range
        var row;
        var rowFirst, rowLast; // inclusive cell-offset range for current row
        var isStart, isEnd;
        var segFirst, segLast; // inclusive cell-offset range for segment
        var seg;

        range = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
        first = this.dateToCellOffset(range.start);
        last = this.dateToCellOffset(range.end.subtract(1, &#39;days&#39;)); // offset of inclusive end date

        for (row = 0; row &lt; rowCnt; row++) {
                rowFirst = row * colCnt;
                rowLast = rowFirst + colCnt - 1;

                // intersect segment&#39;s offset range with the row&#39;s
                segFirst = Math.max(rowFirst, first);
                segLast = Math.min(rowLast, last);

                // deal with in-between indices
                segFirst = Math.ceil(segFirst); // in-between starts round to next cell
                segLast = Math.floor(segLast); // in-between ends round to prev cell

                if (segFirst &lt;= segLast) { // was there any intersection with the current row?

                        // must be matching integers to be the segment&#39;s start/end
                        isStart = segFirst === first;
                        isEnd = segLast === last;

                        // translate offsets to be relative to start-of-row
                        segFirst -= rowFirst;
                        segLast -= rowFirst;

                        seg = { row: row, isStart: isStart, isEnd: isEnd };
                        if (isRTL) {
                                seg.leftCol = colCnt - segLast - 1;
                                seg.rightCol = colCnt - segFirst - 1;
                        }
                        else {
                                seg.leftCol = segFirst;
                                seg.rightCol = segLast;
                        }
                        segs.push(seg);
                }
        }

        return segs;
},

// Given a date, returns its chronolocial cell-offset from the first cell of the grid.
// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
// If before the first offset, returns a negative number.
// If after the last offset, returns an offset past the last cell offset.
// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
dateToCellOffset: function(date) {
        var offsets = this.dayToCellOffsets;
        var day = date.diff(this.start, &#39;days&#39;);

        if (day &lt; 0) {
                return offsets[0] - 1;
        }
        else if (day &gt;= offsets.length) {
                return offsets[offsets.length - 1] + 1;
        }
        else {
                return offsets[day];
        }
},

/* Event Drag Visualization
------------------------------------------------------------------------------------------------------------------*/
// TODO: move to DayGrid.event, similar to what we did with Grid&#39;s drag methods

// Renders a visual indication of an event or external element being dragged.
// The dropLocation&#39;s end can be null. seg can be null. See Grid::renderDrag for more info.
renderDrag: function(dropLocation, seg) {
        var opacity;

        // always render a highlight underneath
        this.renderHighlight(
                this.view.calendar.ensureVisibleEventRange(dropLocation) // needs to be a proper range
        );

        // if a segment from the same calendar but another component is being dragged, render a helper event
        if (seg &amp;&amp; !seg.el.closest(this.el).length) {

                this.renderRangeHelper(dropLocation, seg);

                opacity = this.view.opt(&#39;dragOpacity&#39;);
                if (opacity !== undefined) {
                        this.helperEls.css(&#39;opacity&#39;, opacity);
                }

                return true; // a helper has been rendered
        }
},

// Unrenders any visual indication of a hovering event
destroyDrag: function() {
        this.destroyHighlight();
        this.destroyHelper();
},

/* Event Resize Visualization
------------------------------------------------------------------------------------------------------------------*/

// Renders a visual indication of an event being resized
renderEventResize: function(range, seg) {
        this.renderHighlight(range);
        this.renderRangeHelper(range, seg);
},

// Unrenders a visual indication of an event being resized
destroyEventResize: function() {
        this.destroyHighlight();
        this.destroyHelper();
},

/* Event Helper
------------------------------------------------------------------------------------------------------------------*/

// Renders a mock &quot;helper&quot; event. `sourceSeg` is the associated internal segment object. It can be null.
renderHelper: function(event, sourceSeg) {
        var helperNodes = [];
        var segs = this.eventsToSegs([ event ]);
        var rowStructs;

        segs = this.renderFgSegEls(segs); // assigns each seg&#39;s el and returns a subset of segs that were rendered
        rowStructs = this.renderSegRows(segs);

        // inject each new event skeleton into each associated row
        this.rowEls.each(function(row, rowNode) {
                var rowEl = $(rowNode); // the .fc-row
                var skeletonEl = $(&#39;&lt;div class=&quot;fc-helper-skeleton&quot;&gt;&lt;table/&gt;&lt;/div&gt;&#39;); // will be absolutely positioned
                var skeletonTop;

                // If there is an original segment, match the top position. Otherwise, put it at the row&#39;s top level
                if (sourceSeg &amp;&amp; sourceSeg.row === row) {
                        skeletonTop = sourceSeg.el.position().top;
                }
                else {
                        skeletonTop = rowEl.find(&#39;.fc-content-skeleton tbody&#39;).position().top;
                }

                skeletonEl.css(&#39;top&#39;, skeletonTop)
                        .find(&#39;table&#39;)
                                .append(rowStructs[row].tbodyEl);

                rowEl.append(skeletonEl);
                helperNodes.push(skeletonEl[0]);
        });

        this.helperEls = $(helperNodes); // array -&gt; jQuery set
},

// Unrenders any visual indication of a mock helper event
destroyHelper: function() {
        if (this.helperEls) {
                this.helperEls.remove();
                this.helperEls = null;
        }
},

/* Fill System (highlight, background events, business hours)
------------------------------------------------------------------------------------------------------------------*/

fillSegTag: &#39;td&#39;, // override the default tag name

// Renders a set of rectangles over the given segments of days.
// Only returns segments that successfully rendered.
renderFill: function(type, segs) {
        var nodes = [];
        var i, seg;
        var skeletonEl;

        segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

        for (i = 0; i &lt; segs.length; i++) {
                seg = segs[i];
                skeletonEl = this.renderFillRow(type, seg);
                this.rowEls.eq(seg.row).append(skeletonEl);
                nodes.push(skeletonEl[0]);
        }

        this.elsByFill[type] = $(nodes);

        return segs;
},

// Generates the HTML needed for one row of a fill. Requires the seg&#39;s el to be rendered.
renderFillRow: function(type, seg) {
        var colCnt = this.colCnt;
        var startCol = seg.leftCol;
        var endCol = seg.rightCol + 1;
        var skeletonEl;
        var trEl;

        skeletonEl = $(
                &#39;&lt;div class=&quot;fc-&#39; + type.toLowerCase() + &#39;-skeleton&quot;&gt;&#39; +
                        &#39;&lt;table&gt;&lt;tr/&gt;&lt;/table&gt;&#39; +
                &#39;&lt;/div&gt;&#39;
        );
        trEl = skeletonEl.find(&#39;tr&#39;);

        if (startCol &gt; 0) {
                trEl.append(&#39;&lt;td colspan=&quot;&#39; + startCol + &#39;&quot;/&gt;&#39;);
        }

        trEl.append(
                seg.el.attr(&#39;colspan&#39;, endCol - startCol)
        );

        if (endCol &lt; colCnt) {
                trEl.append(&#39;&lt;td colspan=&quot;&#39; + (colCnt - endCol) + &#39;&quot;/&gt;&#39;);
        }

        this.bookendCells(trEl, type);

        return skeletonEl;
}</pre>

<p>});</p>

<p>;;</p>

<p>/* Event-rendering methods for the DayGrid class
———————————————————————————————————————-*/</p>

<p>DayGrid.mixin({</p>

<pre>rowStructs: null, // an array of objects, each holding information about a row&#39;s foreground event-rendering

// Unrenders all events currently rendered on the grid
destroyEvents: function() {
        this.destroySegPopover(); // removes the &quot;more..&quot; events popover
        FC.Grid.prototype.destroyEvents.apply(this, arguments); // calls the super-method
},

// Retrieves all rendered segment objects currently rendered on the grid
getEventSegs: function() {
        return FC.Grid.prototype.getEventSegs.call(this) // get the segments from the super-method
                .concat(this.popoverSegs || []); // append the segments from the &quot;more...&quot; popover
},

// Renders the given background event segments onto the grid
renderBgSegs: function(segs) {

        // don&#39;t render timed background events
        var allDaySegs = $.grep(segs, function(seg) {
                return seg.event.allDay;
        });

        return FC.Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method
},

// Renders the given foreground event segments onto the grid
renderFgSegs: function(segs) {
        var rowStructs;

        // render an `.el` on each seg
        // returns a subset of the segs. segs that were actually rendered
        segs = this.renderFgSegEls(segs);

        rowStructs = this.rowStructs = this.renderSegRows(segs);

        // append to each row&#39;s content skeleton
        this.rowEls.each(function(i, rowNode) {
                $(rowNode).find(&#39;.fc-content-skeleton &gt; table&#39;).append(
                        rowStructs[i].tbodyEl
                );
        });

        return segs; // return only the segs that were actually rendered
},

// Unrenders all currently rendered foreground event segments
destroyFgSegs: function() {
        var rowStructs = this.rowStructs || [];
        var rowStruct;

        while ((rowStruct = rowStructs.pop())) {
                rowStruct.tbodyEl.remove();
        }

        this.rowStructs = null;
},

// Uses the given events array to generate &lt;tbody&gt; elements that should be appended to each row&#39;s content skeleton.
// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
renderSegRows: function(segs) {
        var rowStructs = [];
        var segRows;
        var row;

        segRows = this.groupSegRows(segs); // group into nested arrays

        // iterate each row of segment groupings
        for (row = 0; row &lt; segRows.length; row++) {
                rowStructs.push(
                        this.renderSegRow(row, segRows[row])
                );
        }

        return rowStructs;
},

// Builds the HTML to be used for the default element for an individual segment
fgSegHtml: function(seg, disableResizing) {
        var view = this.view;
        var event = seg.event;
        var isDraggable = view.isEventDraggable(event);
        var isResizable = !disableResizing &amp;&amp; event.allDay &amp;&amp; seg.isEnd &amp;&amp; view.isEventResizable(event);
        var classes = this.getSegClasses(seg, isDraggable, isResizable);
        var skinCss = this.getEventSkinCss(event);
        var timeHtml = &#39;&#39;;
        var titleHtml;

        classes.unshift(&#39;fc-day-grid-event&#39;);

        // Only display a timed events time if it is the starting segment
        if (!event.allDay &amp;&amp; seg.isStart) {
                timeHtml = &#39;&lt;span class=&quot;fc-time&quot;&gt;&#39; + htmlEscape(this.getEventTimeText(event)) + &#39;&lt;/span&gt;&#39;;
        }

        titleHtml =
                &#39;&lt;span class=&quot;fc-title&quot;&gt;&#39; +
                        (htmlEscape(event.title || &#39;&#39;) || &#39;&amp;nbsp;&#39;) + // we always want one line of height
                &#39;&lt;/span&gt;&#39;;

        return &#39;&lt;a class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&#39; +
                        (event.url ?
                                &#39; href=&quot;&#39; + htmlEscape(event.url) + &#39;&quot;&#39; :
                                &#39;&#39;
                                ) +
                        (skinCss ?
                                &#39; style=&quot;&#39; + skinCss + &#39;&quot;&#39; :
                                &#39;&#39;
                                ) +
                &#39;&gt;&#39; +
                        &#39;&lt;div class=&quot;fc-content&quot;&gt;&#39; +
                                (this.isRTL ?
                                        titleHtml + &#39; &#39; + timeHtml : // put a natural space in between
                                        timeHtml + &#39; &#39; + titleHtml   //
                                        ) +
                        &#39;&lt;/div&gt;&#39; +
                        (isResizable ?
                                &#39;&lt;div class=&quot;fc-resizer&quot;/&gt;&#39; :
                                &#39;&#39;
                                ) +
                &#39;&lt;/a&gt;&#39;;
},

// Given a row # and an array of segments all in the same row, render a &lt;tbody&gt; element, a skeleton that contains
// the segments. Returns object with a bunch of internal data about how the render was calculated.
renderSegRow: function(row, rowSegs) {
        var colCnt = this.colCnt;
        var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
        var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
        var tbody = $(&#39;&lt;tbody/&gt;&#39;);
        var segMatrix = []; // lookup for which segments are rendered into which level+col cells
        var cellMatrix = []; // lookup for all &lt;td&gt; elements of the level+col matrix
        var loneCellMatrix = []; // lookup for &lt;td&gt; elements that only take up a single column
        var i, levelSegs;
        var col;
        var tr;
        var j, seg;
        var td;

        // populates empty cells from the current column (`col`) to `endCol`
        function emptyCellsUntil(endCol) {
                while (col &lt; endCol) {
                        // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
                        td = (loneCellMatrix[i - 1] || [])[col];
                        if (td) {
                                td.attr(
                                        &#39;rowspan&#39;,
                                        parseInt(td.attr(&#39;rowspan&#39;) || 1, 10) + 1
                                );
                        }
                        else {
                                td = $(&#39;&lt;td/&gt;&#39;);
                                tr.append(td);
                        }
                        cellMatrix[i][col] = td;
                        loneCellMatrix[i][col] = td;
                        col++;
                }
        }

        for (i = 0; i &lt; levelCnt; i++) { // iterate through all levels
                levelSegs = segLevels[i];
                col = 0;
                tr = $(&#39;&lt;tr/&gt;&#39;);

                segMatrix.push([]);
                cellMatrix.push([]);
                loneCellMatrix.push([]);

                // levelCnt might be 1 even though there are no actual levels. protect against this.
                // this single empty row is useful for styling.
                if (levelSegs) {
                        for (j = 0; j &lt; levelSegs.length; j++) { // iterate through segments in level
                                seg = levelSegs[j];

                                emptyCellsUntil(seg.leftCol);

                                // create a container that occupies or more columns. append the event element.
                                td = $(&#39;&lt;td class=&quot;fc-event-container&quot;/&gt;&#39;).append(seg.el);
                                if (seg.leftCol != seg.rightCol) {
                                        td.attr(&#39;colspan&#39;, seg.rightCol - seg.leftCol + 1);
                                }
                                else { // a single-column segment
                                        loneCellMatrix[i][col] = td;
                                }

                                while (col &lt;= seg.rightCol) {
                                        cellMatrix[i][col] = td;
                                        segMatrix[i][col] = seg;
                                        col++;
                                }

                                tr.append(td);
                        }
                }

                emptyCellsUntil(colCnt); // finish off the row
                this.bookendCells(tr, &#39;eventSkeleton&#39;);
                tbody.append(tr);
        }

        return { // a &quot;rowStruct&quot;
                row: row, // the row number
                tbodyEl: tbody,
                cellMatrix: cellMatrix,
                segMatrix: segMatrix,
                segLevels: segLevels,
                segs: rowSegs
        };
},

// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
buildSegLevels: function(segs) {
        var levels = [];
        var i, seg;
        var j;

        // Give preference to elements with certain criteria, so they have
        // a chance to be closer to the top.
        segs.sort(FC.compareSegs);

        for (i = 0; i &lt; segs.length; i++) {
                seg = segs[i];

                // loop through levels, starting with the topmost, until the segment doesn&#39;t collide with other segments
                for (j = 0; j &lt; levels.length; j++) {
                        if (!isDaySegCollision(seg, levels[j])) {
                                break;
                        }
                }
                // `j` now holds the desired subrow index
                seg.level = j;

                // create new level array if needed and append segment
                (levels[j] || (levels[j] = [])).push(seg);
        }

        // order segments left-to-right. very important if calendar is RTL
        for (j = 0; j &lt; levels.length; j++) {
                levels[j].sort(compareDaySegCols);
        }

        return levels;
},

// Given a flat array of segments, return an array of sub-arrays, grouped by each segment&#39;s row
groupSegRows: function(segs) {
        var segRows = [];
        var i;

        for (i = 0; i &lt; this.rowCnt; i++) {
                segRows.push([]);
        }

        for (i = 0; i &lt; segs.length; i++) {
                segRows[segs[i].row].push(segs[i]);
        }

        return segRows;
}</pre>

<p>});</p>

<p>// Computes whether two segments&#39; columns collide. They are assumed to
be in the same row. function isDaySegCollision(seg, otherSegs) {</p>

<pre>var i, otherSeg;

for (i = 0; i &lt; otherSegs.length; i++) {
        otherSeg = otherSegs[i];

        if (
                otherSeg.leftCol &lt;= seg.rightCol &amp;&amp;
                otherSeg.rightCol &gt;= seg.leftCol
        ) {
                return true;
        }
}

return false;</pre>

<p>}</p>

<p>// A cmp function for determining the leftmost event function
compareDaySegCols(a, b) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">leftCol</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">leftCol</span>;
</pre>

<p>}</p>

<p>function htmlEscape(s) {</p>

<pre>return (s + &#39;&#39;).replace(/&amp;/g, &#39;&amp;amp;&#39;)
        .replace(/&lt;/g, &#39;&amp;lt;&#39;)
        .replace(/&gt;/g, &#39;&amp;gt;&#39;)
        .replace(/&#39;/g, &#39;&amp;#039;&#39;)
        .replace(/&quot;/g, &#39;&amp;quot;&#39;)
        .replace(/\n/g, &#39;&lt;br /&gt;&#39;);</pre>

<p>}</p>

<p>;;</p>

<p>/* Methods relate to limiting the number events for a given day on a
DayGrid ———————————————————————————————————————-*/ // NOTE: all the segs
being passed around in here are foreground segs</p>

<p>DayGrid.mixin({</p>

<pre>segPopover: null, // the Popover that holds events that can&#39;t fit in a cell. null when not visible
popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible

destroySegPopover: function() {
        if (this.segPopover) {
                this.segPopover.hide(); // will trigger destruction of `segPopover` and `popoverSegs`
        }
},

// Limits the number of &quot;levels&quot; (vertically stacking layers of events) for each row of the grid.
// `levelLimit` can be false (don&#39;t limit), a number, or true (should be computed).
limitRows: function(levelLimit) {
        var rowStructs = this.rowStructs || [];
        var row; // row #
        var rowLevelLimit;

        for (row = 0; row &lt; rowStructs.length; row++) {
                this.unlimitRow(row);

                if (!levelLimit) {
                        rowLevelLimit = false;
                }
                else if (typeof levelLimit === &#39;number&#39;) {
                        rowLevelLimit = levelLimit;
                }
                else {
                        rowLevelLimit = this.computeRowLevelLimit(row);
                }

                if (rowLevelLimit !== false) {
                        this.limitRow(row, rowLevelLimit);
                }
        }
},

// Computes the number of levels a row will accomodate without going outside its bounds.
// Assumes the row is &quot;rigid&quot; (maintains a constant height regardless of what is inside).
// `row` is the row number.
computeRowLevelLimit: function(row) {
        var rowEl = this.rowEls.eq(row); // the containing &quot;fake&quot; row div
        var rowHeight = rowEl.height(); // TODO: cache somehow?
        var trEls = this.rowStructs[row].tbodyEl.children();
        var i, trEl;

        // Reveal one level &lt;tr&gt; at a time and stop when we find one out of bounds
        for (i = 0; i &lt; trEls.length; i++) {
                trEl = trEls.eq(i).removeClass(&#39;fc-limited&#39;); // get and reveal
                if (trEl.position().top + trEl.outerHeight() &gt; rowHeight) {
                        return i;
                }
        }

        return false; // should not limit at all
},

// Limits the given grid row to the maximum number of levels and injects &quot;more&quot; links if necessary.
// `row` is the row number.
// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
limitRow: function(row, levelLimit) {
        var _this = this;
        var rowStruct = this.rowStructs[row];
        var moreNodes = []; // array of &quot;more&quot; &lt;a&gt; links and &lt;td&gt; DOM nodes
        var col = 0; // col #, left-to-right (not chronologically)
        var cell;
        var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
        var cellMatrix; // a matrix (by level, then column) of all &lt;td&gt; jQuery elements in the row
        var limitedNodes; // array of temporarily hidden level &lt;tr&gt; and segment &lt;td&gt; DOM nodes
        var i, seg;
        var segsBelow; // array of segment objects below `seg` in the current `col`
        var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
        var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs&#39;s first column)
        var td, rowspan;
        var segMoreNodes; // array of &quot;more&quot; &lt;td&gt; cells that will stand-in for the current seg&#39;s cell
        var j;
        var moreTd, moreWrap, moreLink;

        // Iterates through empty level cells and places &quot;more&quot; links inside if need be
        function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`
                while (col &lt; endCol) {
                        cell = _this.getCell(row, col);
                        segsBelow = _this.getCellSegs(cell, levelLimit);
                        if (segsBelow.length) {
                                td = cellMatrix[levelLimit - 1][col];
                                moreLink = _this.renderMoreLink(cell, segsBelow);
                                moreWrap = $(&#39;&lt;div/&gt;&#39;).append(moreLink);
                                td.append(moreWrap);
                                moreNodes.push(moreWrap[0]);
                        }
                        col++;
                }
        }

        if (levelLimit &amp;&amp; levelLimit &lt; rowStruct.segLevels.length) { // is it actually over the limit?
                levelSegs = rowStruct.segLevels[levelLimit - 1];
                cellMatrix = rowStruct.cellMatrix;

                limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level &lt;tr&gt; elements past the limit
                        .addClass(&#39;fc-limited&#39;).get(); // hide elements and get a simple DOM-nodes array

                // iterate though segments in the last allowable level
                for (i = 0; i &lt; levelSegs.length; i++) {
                        seg = levelSegs[i];
                        emptyCellsUntil(seg.leftCol); // process empty cells before the segment

                        // determine *all* segments below `seg` that occupy the same columns
                        colSegsBelow = [];
                        totalSegsBelow = 0;
                        while (col &lt;= seg.rightCol) {
                                cell = this.getCell(row, col);
                                segsBelow = this.getCellSegs(cell, levelLimit);
                                colSegsBelow.push(segsBelow);
                                totalSegsBelow += segsBelow.length;
                                col++;
                        }

                        if (totalSegsBelow) { // do we need to replace this segment with one or many &quot;more&quot; links?
                                td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment&#39;s parent cell
                                rowspan = td.attr(&#39;rowspan&#39;) || 1;
                                segMoreNodes = [];

                                // make a replacement &lt;td&gt; for each column the segment occupies. will be one for each colspan
                                for (j = 0; j &lt; colSegsBelow.length; j++) {
                                        moreTd = $(&#39;&lt;td class=&quot;fc-more-cell&quot;/&gt;&#39;).attr(&#39;rowspan&#39;, rowspan);
                                        segsBelow = colSegsBelow[j];
                                        cell = this.getCell(row, seg.leftCol + j);
                                        moreLink = this.renderMoreLink(cell, [ seg ].concat(segsBelow)); // count seg as hidden too
                                        moreWrap = $(&#39;&lt;div/&gt;&#39;).append(moreLink);
                                        moreTd.append(moreWrap);
                                        segMoreNodes.push(moreTd[0]);
                                        moreNodes.push(moreTd[0]);
                                }

                                td.addClass(&#39;fc-limited&#39;).after($(segMoreNodes)); // hide original &lt;td&gt; and inject replacements
                                limitedNodes.push(td[0]);
                        }
                }

                emptyCellsUntil(this.colCnt); // finish off the level
                rowStruct.moreEls = $(moreNodes); // for easy undoing later
                rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
        }
},

// Reveals all levels and removes all &quot;more&quot;-related elements for a grid&#39;s row.
// `row` is a row number.
unlimitRow: function(row) {
        var rowStruct = this.rowStructs[row];

        if (rowStruct.moreEls) {
                rowStruct.moreEls.remove();
                rowStruct.moreEls = null;
        }

        if (rowStruct.limitedEls) {
                rowStruct.limitedEls.removeClass(&#39;fc-limited&#39;);
                rowStruct.limitedEls = null;
        }
},

// Renders an &lt;a&gt; element that represents hidden event element for a cell.
// Responsible for attaching click handler as well.
renderMoreLink: function(cell, hiddenSegs) {
        var _this = this;
        var view = this.view;

        return $(&#39;&lt;a class=&quot;fc-more&quot;/&gt;&#39;)
                .text(
                        this.getMoreLinkText(hiddenSegs.length)
                )
                .on(&#39;click&#39;, function(ev) {
                        var clickOption = view.opt(&#39;eventLimitClick&#39;);
                        var date = cell.start;
                        var moreEl = $(this);
                        var dayEl = _this.getCellDayEl(cell);
                        var allSegs = _this.getCellSegs(cell);

                        // rescope the segments to be within the cell&#39;s date
                        var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
                        var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

                        if (typeof clickOption === &#39;function&#39;) {
                                // the returned value can be an atomic option
                                clickOption = view.trigger(&#39;eventLimitClick&#39;, null, {
                                        date: date,
                                        dayEl: dayEl,
                                        moreEl: moreEl,
                                        segs: reslicedAllSegs,
                                        hiddenSegs: reslicedHiddenSegs
                                }, ev);
                        }

                        if (clickOption === &#39;popover&#39;) {
                                _this.showSegPopover(cell, moreEl, reslicedAllSegs);
                        }
                        else if (typeof clickOption === &#39;string&#39;) { // a view name
                                view.calendar.zoomTo(date, clickOption);
                        }
                });
},

// Reveals the popover that displays all events within a cell
showSegPopover: function(cell, moreLink, segs) {
        var _this = this;
        var view = this.view;
        var moreWrap = moreLink.parent(); // the &lt;div&gt; wrapper around the &lt;a&gt;
        var topEl; // the element we want to match the top coordinate of
        var options;

        if (this.rowCnt == 1) {
                topEl = view.el; // will cause the popover to cover any sort of header
        }
        else {
                topEl = this.rowEls.eq(cell.row); // will align with top of row
        }

        options = {
                className: &#39;fc-more-popover&#39;,
                content: this.renderSegPopoverContent(cell, segs),
                parentEl: this.el,
                top: topEl.offset().top,
                autoHide: true, // when the user clicks elsewhere, hide the popover
                viewportConstrain: view.opt(&#39;popoverViewportConstrain&#39;),
                hide: function() {
                        // destroy everything when the popover is hidden
                        _this.segPopover.destroy();
                        _this.segPopover = null;
                        _this.popoverSegs = null;
                }
        };

        // Determine horizontal coordinate.
        // We use the moreWrap instead of the &lt;td&gt; to avoid border confusion.
        if (this.isRTL) {
                options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
        }
        else {
                options.left = moreWrap.offset().left - 1; // -1 to be over cell border
        }

        this.segPopover = new Popover(options);
        this.segPopover.show();
},

// Builds the inner DOM contents of the segment popover
renderSegPopoverContent: function(cell, segs) {
        var view = this.view;
        var isTheme = view.opt(&#39;theme&#39;);
        var title = cell.start.format(view.opt(&#39;dayPopoverFormat&#39;));
        var content = $(
                &#39;&lt;div class=&quot;fc-header &#39; + view.widgetHeaderClass + &#39;&quot;&gt;&#39; +
                        &#39;&lt;span class=&quot;fc-close &#39; +
                                (isTheme ? &#39;ui-icon ui-icon-closethick&#39; : &#39;fc-icon fc-icon-x&#39;) +
                        &#39;&quot;&gt;&lt;/span&gt;&#39; +
                        &#39;&lt;span class=&quot;fc-title&quot;&gt;&#39; +
                                htmlEscape(title) +
                        &#39;&lt;/span&gt;&#39; +
                        &#39;&lt;div class=&quot;fc-clear&quot;/&gt;&#39; +
                &#39;&lt;/div&gt;&#39; +
                &#39;&lt;div class=&quot;fc-body &#39; + view.widgetContentClass + &#39;&quot;&gt;&#39; +
                        &#39;&lt;div class=&quot;fc-event-container&quot;&gt;&lt;/div&gt;&#39; +
                &#39;&lt;/div&gt;&#39;
        );
        var segContainer = content.find(&#39;.fc-event-container&#39;);
        var i;

        // render each seg&#39;s `el` and only return the visible segs
        segs = this.renderFgSegEls(segs, true); // disableResizing=true
        this.popoverSegs = segs;

        for (i = 0; i &lt; segs.length; i++) {

                // because segments in the popover are not part of a grid coordinate system, provide a hint to any
                // grids that want to do drag-n-drop about which cell it came from
                segs[i].cell = cell;

                segContainer.append(segs[i].el);
        }

        return content;
},

// Given the events within an array of segment objects, reslice them to be in a single day
resliceDaySegs: function(segs, dayDate) {

        // build an array of the original events
        var events = $.map(segs, function(seg) {
                return seg.event;
        });

        var dayStart = dayDate.clone().stripTime();
        var dayEnd = dayStart.clone().add(1, &#39;days&#39;);
        var dayRange = { start: dayStart, end: dayEnd };

        // slice the events with a custom slicing function
        return this.eventsToSegs(
                events,
                function(range) {
                        var seg = intersectionToSeg(range, dayRange); // undefind if no intersection
                        return seg ? [ seg ] : []; // must return an array of segments
                }
        );
},

// Generates the text that should be inside a &quot;more&quot; link, given the number of events it represents
getMoreLinkText: function(num) {
        var opt = this.view.opt(&#39;eventLimitText&#39;);

        if (typeof opt === &#39;function&#39;) {
                return opt(num);
        }
        else {
                return &#39;+&#39; + num + &#39; &#39; + opt;
        }
},

// Returns segments within a given cell.
// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
getCellSegs: function(cell, startLevel) {
        var segMatrix = this.rowStructs[cell.row].segMatrix;
        var level = startLevel || 0;
        var segs = [];
        var seg;

        while (level &lt; segMatrix.length) {
                seg = segMatrix[level][cell.col];
                if (seg) {
                        segs.push(seg);
                }
                level++;
        }

        return segs;
}</pre>

<p>});</p>

<p>;;</p>

<p>var ListView = FC.views.list = FC.View.extend({</p>

<pre>dayGrid: null, // the main subcomponent that does most of the heavy lifting
weekNumberWidth: null, // width of all the week-number cells running down the side
headRowEl: null, // the fake row element of the day-of-week header
defultEventLimit: 5, //we need to show some events in each cell 
viewDateOnLeft: false, //true to display date on left, false to display above the day

initialize: function() {
        this.dayGrid = new DayGrid(this);
        this.coordMap = this.dayGrid.coordMap; // the view&#39;s date-to-cell mapping is identical to the subcomponent&#39;s
},

// Sets the display range and computes all necessary dates
setRange: function(range) {
        FC.View.prototype.setRange.call(this, range); // call the super-method

        this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit); // do before setRange
        this.dayGrid.setRange(range);
},

// Renders the view into `this.el`, which should already be assigned.
render: function() {
        this.dayGrid.colCnt = 1;
        this.dayGrid.rowCnt = this.dayGrid.cellDates.length;
        this.dayGrid.numbersVisible = true;

        if (this.opt(&#39;viewDateOnLeft&#39;)) {
                this.viewDateOnLeft = this.opt(&#39;viewDateOnLeft&#39;);
                this.el.removeClass(&#39;fc-display-date-above&#39;);
        }
        else {
                this.el.addClass(&#39;fc-display-date-above&#39;);
        }

        this.el.addClass(&#39;fc-basic-view&#39;).html(this.renderHtml());

        this.headRowEl = this.el.find(&#39;thead .fc-row&#39;);

        this.scrollerEl = this.el.find(&#39;.fc-day-grid-container&#39;);
        this.dayGrid.coordMap.containerEl = this.scrollerEl; // constrain clicks/etc to the dimensions of the scroller

        this.dayGrid.el = this.el.find(&#39;.fc-day-grid&#39;);
        this.dayGrid.render(this.hasRigidRows());

        FC.View.prototype.render.call(this); // call the super-method
},

// Make subcomponents ready for cleanup
destroy: function() {
        this.dayGrid.destroy();
        FC.View.prototype.destroy.call(this); // call the super-method
},

// Builds the HTML skeleton for the view.
// The day-grid component will render inside of a container defined by this HTML.
renderHtml: function() {
        return &#39;&#39; +
                &#39;&lt;table&gt;&#39; +
                        &#39;&lt;tbody&gt;&#39; +
                                &#39;&lt;tr&gt;&#39; +
                                        &#39;&lt;td class=&quot;&#39; + this.widgetContentClass + &#39;&quot;&gt;&#39; +
                                                &#39;&lt;div class=&quot;fc-day-grid-container&quot;&gt;&#39; +
                                                        &#39;&lt;div class=&quot;fc-day-grid&quot;/&gt;&#39; +
                                                &#39;&lt;/div&gt;&#39; +
                                        &#39;&lt;/td&gt;&#39; +
                                &#39;&lt;/tr&gt;&#39; +
                        &#39;&lt;/tbody&gt;&#39; +
                &#39;&lt;/table&gt;&#39;;
},

// Generates the HTML that will go before the day-of week header cells.
// Queried by the DayGrid subcomponent when generating rows. Ordering depends on isRTL.
headIntroHtml: function() {
        if (this.viewDateOnLeft === true) {
                return &#39;&#39; +
                        &#39;&lt;th class=&quot;fc-week-number &#39; + this.widgetHeaderClass + &#39;&quot; &#39; + this.weekNumberStyleAttr() + &#39;&gt;&#39; +
                                &#39;&lt;span&gt;&#39; +
                                &#39;&lt;/span&gt;&#39; +
                        &#39;&lt;/th&gt;&#39;;
        }
        else {
                return &#39;&#39;;
        }
},

// Generates the HTML that will go before content-skeleton cells that display the day/week numbers.
// Queried by the DayGrid subcomponent. Ordering depends on isRTL.
numberIntroHtml: function(row) {
        if (this.viewDateOnLeft === true) {
                return &#39;&#39; +
                        &#39;&lt;td class=&quot;fc-week-number&quot; &#39; + this.weekNumberStyleAttr() + &#39;&gt;&#39; +
                                &#39;&lt;span&gt;&#39; + // needed for matchCellWidths
                                        this.dayGrid.getCell(row, 0).start.format(&#39;ddd MMM D, YYYY&#39;) +
                                &#39;&lt;/span&gt;&#39; +
                        &#39;&lt;/td&gt;&#39;;
        }
        else {
                return &#39;&#39;;
        }
},

// Generates the HTML that goes before the day bg cells for each day-row.
// Queried by the DayGrid subcomponent. Ordering depends on isRTL.
dayIntroHtml: function() {
        if (this.viewDateOnLeft === true) {
                return &#39;&lt;td class=&quot;fc-week-number &#39; + this.widgetContentClass + &#39;&quot; &#39; +
                        this.weekNumberStyleAttr() + &#39;&gt;&lt;/td&gt;&#39;;
        }
        else {
                return &#39;&#39;;
        }
},

// Generates the HTML that goes before every other type of row generated by DayGrid. Ordering depends on isRTL.
// Affects helper-skeleton and highlight-skeleton rows.
introHtml: function() {
        if (this.viewDateOnLeft === true) {
                return &#39;&lt;td class=&quot;fc-week-number&quot; &#39; + this.weekNumberStyleAttr() + &#39;&gt;&lt;/td&gt;&#39;;
        }
        else {
                return &#39;&#39;;
        }
},

// Generates the HTML for the &lt;td&gt;s of the &quot;number&quot; row in the DayGrid&#39;s content skeleton.
// The number row will only exist if either day numbers or week numbers are turned on.
numberCellHtml: function(cell) {
        if (this.viewDateOnLeft === true) {
                return &#39;&lt;td/&gt;&#39;;
        }
        else {
                var date = cell.start;
                var classes;

                classes = this.dayGrid.getDayClasses(date);
                classes.unshift(&#39;fc-day-number&#39;);

                return &#39;&#39; +
                        &#39;&lt;td class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot; data-date=&quot;&#39; + date.format() + &#39;&quot;&gt;&#39; +
                                &#39;&lt;span class=&quot;fc-list-header-left&quot;&gt;&#39; +
                                        date.format(&#39;dddd&#39;) +
                                &#39;&lt;/span&gt;&#39; +
                                &#39;&lt;span class=&quot;fc-list-header-right&quot;&gt;&#39; +
                                        date.format(&#39;MMM D, YYYY&#39;) +
                                &#39;&lt;/span&gt;&#39; +
                        &#39;&lt;/td&gt;&#39;;
        }
},

// Generates an HTML attribute string for setting the width of the week number column, if it is known
weekNumberStyleAttr: function() {
        if (this.weekNumberWidth !== null) {
                return &#39;style=&quot;width:&#39; + this.weekNumberWidth + &#39;px&quot;&#39;;
        }
        return &#39;&#39;;
},

// Determines whether each row should have a constant height
hasRigidRows: function() {
        var eventLimit = this.opt(&#39;eventLimit&#39;);
        if (eventLimit === true) {
                eventLimit = this.defultEventLimit;
        }

        return eventLimit &amp;&amp; typeof eventLimit !== &#39;number&#39;;
},

/* Dimensions
------------------------------------------------------------------------------------------------------------------*/

// Refreshes the horizontal dimensions of the view
updateWidth: function() {
        // Make sure all week number cells running down the side have the same width.
        // Record the width for cells created later.
        this.weekNumberWidth = matchCellWidths(
                this.el.find(&#39;.fc-week-number&#39;)
        );
},

// Adjusts the vertical dimensions of the view to the specified values
setHeight: function(totalHeight, isAuto) {
        var eventLimit = this.opt(&#39;eventLimit&#39;);
        if (eventLimit === true) {
                eventLimit = this.defultEventLimit;
        }
        var scrollerHeight;

        // reset all heights to be natural
        unsetScroller(this.scrollerEl);
        uncompensateScroll(this.headRowEl);

        this.dayGrid.destroySegPopover(); // kill the &quot;more&quot; popover if displayed

        // is the event limit a constant level number?
        if (eventLimit &amp;&amp; typeof eventLimit === &#39;number&#39;) {
                this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
        }

        scrollerHeight = this.computeScrollerHeight(totalHeight);
        this.setGridHeight(scrollerHeight, isAuto);

        // is the event limit dynamically calculated?
        if (eventLimit &amp;&amp; typeof eventLimit !== &#39;number&#39;) {
                this.dayGrid.limitRows(eventLimit); // limit the levels after the grid&#39;s row heights have been set
        }

        if (!isAuto &amp;&amp; setPotentialScroller(this.scrollerEl, scrollerHeight)) { // using scrollbars?

                compensateScroll(this.headRowEl, getScrollbarWidths(this.scrollerEl));

                // doing the scrollbar compensation might have created text overflow which created more height. redo
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scrollerEl.height(scrollerHeight);

                this.restoreScroll();
        }
},

// Sets the height of just the DayGrid component in this view
setGridHeight: function(height, isAuto) {
        if (isAuto) {
                undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
        }
        else {
                distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
        }
},

/* Events
------------------------------------------------------------------------------------------------------------------*/

// Renders the given events onto the view and populates the segments array
renderEvents: function(events) {
        this.dayGrid.renderEvents(events);

        this.updateHeight(); // must compensate for events that overflow the row

        FC.View.prototype.renderEvents.call(this, events); // call the super-method
},

// Retrieves all segment objects that are rendered in the view
getSegs: function() {
        return this.dayGrid.getSegs();
},

// Unrenders all event elements and clears internal segment data
destroyEvents: function() {
        FC.View.prototype.destroyEvents.call(this); // do this before dayGrid&#39;s segs have been cleared

        this.recordScroll(); // removing events will reduce height and mess with the scroll, so record beforehand
        this.dayGrid.destroyEvents();

        // we DON&#39;T need to call updateHeight() because:
        // A) a renderEvents() call always happens after this, which will eventually call updateHeight()
        // B) in IE8, this causes a flash whenever events are rerendered
},

/* Event Dragging
------------------------------------------------------------------------------------------------------------------*/

// Renders a visual indication of an event being dragged over the view.
// A returned value of `true` signals that a mock &quot;helper&quot; event has been rendered.
renderDrag: function(start, end, seg) {
        return this.dayGrid.renderDrag(start, end, seg);
},

// Unrenders the visual indication of an event being dragged over the view
destroyDrag: function() {
        this.dayGrid.destroyDrag();
},

/* Selection
------------------------------------------------------------------------------------------------------------------*/

// Renders a visual indication of a selection
renderSelection: function(start, end) {
        this.dayGrid.renderSelection(start, end);
},

// Unrenders a visual indications of a selection
destroySelection: function() {
        this.dayGrid.destroySelection();
}</pre>

<p>}); ListView.duration = { months: 1 };</p>

<p>FC.views.listMonth = {</p>

<pre>type: &#39;list&#39;,
duration: { weeks: 4 },
buttonText: &#39;month&#39;</pre>

<p>};</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

